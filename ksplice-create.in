#!/usr/bin/perl

# Copyright (C) 2007-2008  Jeffrey Brian Arnold <jbarnold@mit.edu>
# Copyright (C) 2008  Anders Kaseorg <andersk@mit.edu>,
#                     Tim Abbott <tabbott@mit.edu>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License, version 2.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
# 02110-1301, USA.

use strict;
use warnings;
use lib 'KSPLICE_DATA_DIR';
use Ksplice;

my ($patchfile, $diffext, $orig_config_dir, $jobs, $kid);
my $description;
my $series = 0;
my @only_targets;
my @extra_match;
my $standalone;
my ($prebuild, $skip_prebuild) = (0, 0);
my @patch_opt = "-p1";
GetOptions(@common_options,
	"id=s" => \$kid,
	"patch=s" => \$patchfile,
	"description=s" => \$description,
	"diffext=s" => \$diffext,
	"prebuild" => \$prebuild,
	"series!" => \$series,
	"only-targets=s" => \@only_targets,
	"extra-match=s" => \@extra_match,
	"standalone!" => \$standalone,
	"skip-prebuild" => \$skip_prebuild,
	"jobs|j:i" => \$jobs,
	"config=s" => \$orig_config_dir,
	"patch-opt=s" => \@patch_opt) or pod2usage(1);

pod2usage(1) if($help || scalar(@ARGV) != 1);
my $actions = (defined $patchfile) + (defined $diffext) + ($prebuild);
pod2usage(1) if($actions != 1);

my ($linuxtree) = (abs_path($ARGV[0]));

if(!defined $orig_config_dir) {
	$orig_config_dir = "$linuxtree/ksplice";
}
else {
	$orig_config_dir = abs_path($orig_config_dir);
	if($orig_config_dir =~ $linuxtree) {
		die "Aborting: User-specified ORIG_CONFIG cannot be KERNEL_SOURCE or a subdirectory";
	}
}
if(!defined $orig_config_dir || ! -d $orig_config_dir) {
	die "Failed to find ORIG_CONFIG directory ($orig_config_dir)";
}
if(! -e "$orig_config_dir/.config") {
	die "Failed to find .config file in ORIG_CONFIG directory";
}
if(! -e "$orig_config_dir/System.map") {
	die "Failed to find System.map file in ORIG_CONFIG directory";
}

my $kernel_headers_dir = "$orig_config_dir/build";
$kernel_headers_dir = $linuxtree unless(-d $kernel_headers_dir);

my @kbuild_flags = ();
if(-e "$orig_config_dir/flags") {
	open(FLAGS, '<', "$orig_config_dir/flags") or die;
	local $/;
	@kbuild_flags = shellwords(scalar <FLAGS>);
	close(FLAGS);
}

$ENV{KSPLICE_VERBOSE} = $Verbose::level;
$ENV{KSPLICE_CONFIG_DIR} = $orig_config_dir;

my @chars = ('a'..'z', 0..9);
$kid = join '', map { $chars[int(rand(36))] } 0..7 if(!defined $kid);
my $ksplice = "ksplice-$kid";
$ENV{KSPLICE_KID} = $kid;

# Some versions of Fedora have System.map files whose symbol addresses disagree
# with the running kernel by a constant address offset.  Here, Ksplice notes the
# System.map address for printk so that it can later compare this address against
# the kernel's address for printk.  This comparison helps Ksplice work around
# this Fedora problem, and this comparison also helps Ksplice detect whether
# the user has provided an incorrect System.map file.
my $map_printk = runstr("$datadir/ksplice-obj.pl", "system_map_lookup", "printk");

print "Starting kernel builds (this process might take a long time)...\n"
    if($Verbose::level >= 0);

$patchfile = abs_path($patchfile) if(defined $patchfile);

my $origdir = getcwd();
chdir($linuxtree);

my @make = ("make", "-rR");
if(defined $jobs) {
	push @make, "-j$jobs";
} elsif(defined $ENV{CONCURRENCY_LEVEL}) {
	push @make, "-j$ENV{CONCURRENCY_LEVEL}";
}

if($Verbose::level >= 2) {
	push @make, "V=1";
} elsif($Verbose::level < 0) {
	push @make, "-s";
}

$ENV{PATH} = "$datadir:$ENV{PATH}";
my @make_ksplice = (@make, "-f", "$datadir/Makefile.ksplice", @kbuild_flags);

sub revert_orig() {
	for(split(/\0/, runstr(qw(find -name *.KSPLICE_* -print0)))) {
		if(my ($file) = m/^(.*)\.KSPLICE_pre$/) {
			if ($series) {
				unlink($_);
			} else {
				rename($_, $file);
			}
			runval("$datadir/ksplice-obj.pl", "snap", "$file.KSPLICE") if(-e "$file.KSPLICE");
		} elsif(m/\.KSPLICE_(?:primary|helper)$/) {
			unlink($_) if(-e $_);
		}
	}
}
revert_orig();

if(!$skip_prebuild) {
	copy("$orig_config_dir/.config", "$linuxtree/.config");
	utime((stat("$orig_config_dir/.config"))[8, 9], "$linuxtree/.config");
	my @snap_flags = ("KSPLICE_MODE=snap");
	if(-e "include/config/kernel.release") {
		push(@snap_flags, "-o", "include/config/kernel.release");
	}
	runval_raw(@make_ksplice, @snap_flags) == 0 or
	    die "Aborting: Prebuild failed";
	sleep(1);
}
exit(0) if($prebuild);

my $tmpdir = tempdir('ksplice-tmp-XXXXXX', TMPDIR => 1, CLEANUP => 1);
copy($patchfile, "$tmpdir/patch") if(defined $patchfile);
$patchfile = "$tmpdir/patch";

if(defined $diffext) {
	open(PATCH, '>', $patchfile) or die;
	for(split(/\0/, runstr("find", "-name", "*$diffext", "-print0"))) {
		my ($file) = /^(.*)\Q$diffext\E/ or die;
		print PATCH runstr("diff", "-u", "--", $file, $_);
	}
	close(PATCH) or die;
	@patch_opt = ("-p0");
}

my $kmodsrc = "$tmpdir/kmodsrc";
runval("cp", "-a", "--", "$datadir/kmodsrc", $kmodsrc);
$ENV{KSPLICE_KMODSRC} = $kmodsrc;

my @make_kmodsrc = (@make, "-C", $kernel_headers_dir, "M=$kmodsrc", "KSPLICE_KID=$kid", "KSPLICE_VERSION=PACKAGE_VERSION", "map_printk=$map_printk");

if (!defined($standalone)) {
	$standalone = (runval_raw(qw(grep -q ^CONFIG_KSPLICE=[ym]$), "$linuxtree/.config") != 0);
}
push(@make_kmodsrc, "KSPLICE_STANDALONE=1") if ($standalone);

runval(@make_kmodsrc);

@patch_opt = ("-s", @patch_opt) if ($Verbose::level < 0);

runval_infile($patchfile, "patch", @patch_opt, "-bz", ".KSPLICE_pre");
push @make_ksplice, "KSPLICE_EXTRA_MATCH=@extra_match" if (@extra_match);
push @make_ksplice, "KSPLICE_ONLY_TARGETS=@only_targets" if (@only_targets);
if(runval_raw(@make_ksplice, "KSPLICE_MODE=diff") != 0) {
	revert_orig() if(defined($diffext));
	die "Aborting: Applying the patch appears to break the kernel build";
}

sub copy_debug {
	my ($file) = @_;
	my ($dir, $base) = (dirname($file), basename($file));
	-d "$tmpdir/objects/$dir" or mkpath("$tmpdir/objects/$dir");
	copy($file, "$tmpdir/objects/$file");
	my $cmdfile = "$dir/.$base.cmd";
	copy($cmdfile, "$tmpdir/objects/$cmdfile") if(-e $cmdfile);
}

mkdir("$tmpdir/objects");
for (split(/\0/, runstr(qw(find -name *.KSPLICE* ! ( -name *.KSPLICE -empty ) ! -name .*.KSPLICE.cmd -print0)))) {
	copy_debug($_);
	copy_debug($1) if (m/^(.*)\.KSPLICE_pre$/);
}

my @modules = ();
foreach(glob(".tmp_versions/*.mod.KSPLICE")) {
	open MOD, '<', $_;
	chomp(my $mod = <MOD>);
	close MOD;
	foreach my $collect ("$mod.o.KSPLICE", "$mod.o.KSPLICE_primary",
			     "$mod.o.KSPLICE_helper") {
		copy($collect, "$kmodsrc/" . basename($collect));
	}
	push @modules, basename($mod);
}

if(!@modules) {
	revert_orig() if(defined($diffext));
	die "Aborting: No changes detected";
}

revert_orig() if(defined($diffext));

runval(@make_kmodsrc, "modules", "KSPLICE_MODULES=@modules");

chdir($tmpdir);
mkdir($ksplice);
move($patchfile, $ksplice);
if ($description) {
	open(DESCRIPTION, ">$ksplice/description");
	print DESCRIPTION "$description\n";
	close(DESCRIPTION);
}
foreach my $mod (@modules) {
	(my $target = $mod) =~ s/-/_/g;
	my $mid = "${kid}_$target";
	my $module = "ksplice-$mid";
	rename("$kmodsrc/$module.ko", "$ksplice/$module.ko");
	rename("$kmodsrc/$module-helper.ko", "$ksplice/$module-helper.ko");
}
rename("$kmodsrc/ksplice-$kid.ko", "$ksplice/ksplice-$kid.ko") if ($standalone);

mkdir("$ksplice/debug");
rename("objects", "$ksplice/debug/objects");
rename("$kmodsrc", "$ksplice/debug/kmodsrc");
runval("tar", "czf", "$ksplice.tar.gz", "--", $ksplice);
copy("$ksplice.tar.gz", "$origdir/$ksplice.tar.gz");

print "Ksplice update tarball written to $ksplice.tar.gz\n";
exit(0);

=head1 NAME

ksplice-create - Create a set of kernel modules for a rebootless kernel update

=head1 SYNOPSIS

B<ksplice-create> [B<--config=>I<ORIG_CONFIG>] B<--patch=>I<PATCH_FILE> I<KERNEL_SOURCE>

B<ksplice-create> [B<--config=>I<ORIG_CONFIG>] B<--diffext=>I<EXTENSION> I<KERNEL_SOURCE>

B<ksplice-create> [B<--config=>I<ORIG_CONFIG>] B<--prebuild> I<KERNEL_SOURCE>

=head1 DESCRIPTION

B<ksplice-create> creates a set of Ksplice kernel modules that, when loaded,
will apply a user-specified source code patch to the running binary kernel.

Before you use B<ksplice-create> on a patch, you should confirm that the
desired source code change does not make any semantic changes to kernel data
structures--that is, changes that would require existing instances of kernel
data structures to be transformed (e.g., a patch that adds a field to a global
data structure would require the existing data structures to change).  If you
use Ksplice on a patch that changes data structure semantics, Ksplice will not
detect the problem and you could experience kernel problems as a result.

The to-be-applied source code patch can be specified by providing a L<patch(1)>
file (B<--patch=>I<PATCH_FILE>) or by providing a file extension
(B<--diffext=>I<EXTENSION>).

If a file extension is specified, then the desired source code patch will be
determined by comparing all of the files in the I<KERNEL_SOURCE> directory tree
whose names end with the extra extension I<EXTENSION> against the corresponding
files without the extra extension.  Only the new files containing the extra
extension in their filenames should be modified.

Here is an example of using a file extension to specify a patch:

 $ cp KERNEL_SOURCE/kernel/sys.c KERNEL_SOURCE/kernel/sys.c.prctl_fixed
 [edit sys.c.prctl_fixed to include the desired changes]
 $ ksplice-create --diffext=.prctl_fixed KERNEL_SOURCE

KERNEL_SOURCE must be a directory containing the to-be-updated kernel's
original source code.  If your Linux distribution applies patches to the Linux
kernel during the kernel build process, then those patches must be applied to
the I<KERNEL_SOURCE> directory before invoking B<ksplice-create> on that
directory.  B<ksplice-create> will not modify the source code in the
I<KERNEL_SOURCE> directory tree, but it will perform a kernel build in that
directory tree.

I<ORIG_CONFIG> can be used to specify the directory containing the
to-be-updated kernel's original F<.config> file and original F<System.map> file
(the files should have exactly those names).  I<ORIG_CONFIG> defaults to
I<KERNEL_SOURCE>B</ksplice>.

The default L<gcc(1)> compiler and L<as(1)> assembler on the system should be as
close to the compiler and assembler originally used to build the running kernel
as possible.  If the current compiler and linker are too different from the
original compiler and linker, B<ksplice-apply> will abort when applying the
update.

B<ksplice-create> outputs a L<tar(1)> file, compressed with L<gzip(1)>,
containing the desired Ksplice update modules.  This tarball will be created in
the current directory, and it can be manipulated using the other Ksplice
utilities, such as B<ksplice-apply>.

The first time that B<ksplice-create> is invoked on a I<KERNEL_SOURCE>
directory, it must build that kernel from scratch, which is much slower than
the rest of the update-creation process.  B<--prebuild> can be used to perform
this initial kernel build without providing a source code patch.

In order to patch a function that has previously been patched by Ksplice, the
user needs to ensure that the I<KERNEL_SOURCE> directory provided to Ksplice
contains the source for the currently running kernel, including any patches
that have previously been applied by Ksplice.

=head1 OPTIONS

=over 8

=item B<-v>, B<--verbose>

Causes B<ksplice-create> to print debugging messages about its progress.  Using
multiple -v options increases the verbosity.  The maximum is 2.

=item B<-j> I<JOBS>, B<--jobs=>I<JOBS>

Specifies the number of jobs to run simultaneously while performing kernel
builds.  B<ksplice-create> also honors the environment variable
CONCURRENCY_LEVEL.

=item B<--patch-opt=>I<OPTIONS>

Can be used to pass options to L<patch(1)>.  If this option is NOT specified, then
B<-p1> is passed to B<patch>.  If this option is specified, then only the
specified options will be passed to B<patch>.  This option can be repeated in
order to pass multiple options to B<patch>.  This option is ignored when the
to-be-applied source code patch is specified using B<--diffext>.

=item B<--id=>I<ID>

Specifies the unique value that will be used as the identifier of the
Ksplice update.  This identifier will, for example, appear in the name
of the update tarball.  By default, a random 8-character ID will be
generated.

=back

=head1 SEE ALSO

L<ksplice-apply(8)>, L<ksplice-view(8)>, L<ksplice-undo(8)>

=head1 BUGS

Please report bugs to <PACKAGE_BUGREPORT>.

=head1 COPYRIGHT

Copyright (C) 2007-2008  Jeffrey Brian Arnold <jbarnold@mit.edu>

Copyright (C) 2008  Anders Kaseorg <andersk@mit.edu>,
                    Tim Abbott <tabbott@mit.edu>

This is free software and documentation.  You can redistribute and/or modify it
under the terms of the GNU General Public License, version 2.

=cut
