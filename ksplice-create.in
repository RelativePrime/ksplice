#!/usr/bin/perl

# Copyright (C) 2008  Jeffrey Brian Arnold <jbarnold@mit.edu>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License, version 2.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
# 02110-1301, USA.

use Getopt::Long;
use Cwd 'abs_path', 'getcwd';
use File::Basename;
use File::Copy;
use File::Path;
use File::Temp qw(tempfile tempdir);
use Fatal qw(:void copy rename move chdir mkdir unlink rmtree);
use Pod::Usage;
use strict;
use warnings;
use lib 'KSPLICE_DATA_DIR';
use ksplice;
use verbose qw(copy rename move chdir mkdir mkpath unlink rmtree tempfile tempdir);

my ($patchfile, $diffext, $orig_config_dir, $jobs, $kid);
my $standalone;
my ($help, $wantversion, $prebuild, $skip_prebuild, $apply, $patch_opt) = (0, 0, 0, 0, 0, "-p1");
Getopt::Long::Configure("bundling");
GetOptions("help|?" => \$help,
	"version" => \$wantversion,
	"verbose|v!" => \$verbose::level,
	"id=s" => \$kid,
	"patch=s" => \$patchfile,
	"diffext=s" => \$diffext,
	"prebuild" => \$prebuild,
	"standalone!" => \$standalone,
	"skip-prebuild" => \$skip_prebuild,
	"jobs|j:i" => \$jobs,
	"config=s" => \$orig_config_dir,
	"apply" => \$apply,
	"patch-opt=s@" => \$patch_opt) or pod2usage(1);

if($wantversion) {
	print $version_str;
	exit(0);
}
pod2usage(1) if($help || scalar(@ARGV) != 1);
my $actions = (defined $patchfile) + (defined $diffext) + ($prebuild);
pod2usage(1) if($actions != 1);

my ($linuxtree) = (abs_path($ARGV[0]));

my $tmpdir = tempdir('ksplice-tmp-XXXXXX', TMPDIR => 1, CLEANUP => 1);
copy($patchfile, "$tmpdir/patch") if(defined $patchfile);
$patchfile = "$tmpdir/patch";

$patch_opt = "-p0" if(defined $diffext);
$patch_opt = join(" ", @$patch_opt) if(ref $patch_opt);

if(!defined $orig_config_dir) {
	$orig_config_dir = "$linuxtree/ksplice";
}
else {
	$orig_config_dir = abs_path($orig_config_dir);
	if($orig_config_dir =~ $linuxtree) {
		die "Aborting: User-specified ORIG_CONFIG cannot be KERNEL_SOURCE or a subdirectory";
	}
}
if(!defined $orig_config_dir || ! -d $orig_config_dir) {
	die "Failed to find ORIG_CONFIG directory ($orig_config_dir)";
}
if(! -e "$orig_config_dir/.config") {
	die "Failed to find .config file in ORIG_CONFIG directory";
}
if(! -e "$orig_config_dir/System.map") {
	die "Failed to find System.map file in ORIG_CONFIG directory";
}

$ENV{KSPLICE_VERBOSE} = $verbose::level;
$ENV{KSPLICE_CONFIG_DIR} = $orig_config_dir;

my @standalone_flag;
my $ksplice_in_kernel = runstr(qw(grep ^CONFIG_KSPLICE=), "$orig_config_dir/.config");
$ksplice_in_kernel =~ s/^CONFIG_KSPLICE=([nmy])/$1/;
chomp($ksplice_in_kernel);
if (!defined($standalone)) {
	$standalone = 0;
	$standalone = 1 if ($ksplice_in_kernel ne 'y' && $ksplice_in_kernel ne 'm');
}
@standalone_flag = qw(KSPLICE_STANDALONE=1) if ($standalone == 1);

copy("$orig_config_dir/.config", "$linuxtree/.config");

my @chars = ('a'..'z', 0..9);
$kid = join '', map { $chars[int(rand(36))] } 0..7 if(!defined $kid);
my $ksplice = "ksplice-$kid";

# Some versions of Fedora have System.map files whose symbol addresses disagree
# with the running kernel by a constant address offset.  Here, Ksplice notes the
# System.map address for printk so that it can later compare this address against
# the kernel's address for printk.  This comparison helps Ksplice work around
# this Fedora problem, and this comparison also helps Ksplice detect whether
# the user has provided an incorrect System.map file.
my $map_printk = runstr("$datadir/ksplice.pl", "system_map_lookup", "printk");

print "Starting kernel builds (this process might take a long time)...\n";
if(!$verbose::level) {
	print "For output during this process, run ksplice-create with the option -v\n";
}

###################################################################
# PHASE 1: Determine which object files are modified by the patch #
# - performs the pre and post kernel builds                       #
# - uses objdiff to identify which ELF sections have changed and  #
#   which ELF symbols are entry points to those sections          #
###################################################################

# We will refer to the object files modified by the patch as the "target object
# files", the ELF sections changed by the patch as the "target sections", and
# the entry points of those sections as the "target entry points".

my $origdir = getcwd();
chdir($linuxtree);
if(defined $diffext) {
	runval("$libexecdir/ksplice-gendiff-reversed >$patchfile . $diffext");
}

my @jlevel = (defined $ENV{CONCURRENCY_LEVEL} ? ("-j$ENV{CONCURRENCY_LEVEL}") : ());
@jlevel = ("-j$jobs") if(defined $jobs);
my @make_ksplice = ("make", "-f", "$datadir/Makefile.ksplice", @jlevel);

sub revert_orig() {
	for(split(/\0/, runstr(qw(find -name *.KSPLICE*pre* -print0)))) {
		if(my ($file) = m/^(.*)\.KSPLICE_pre$/) {
			rename($_, $file);
			unlink("$file.KSPLICE") if(-e "$file.KSPLICE");
		} elsif(m/\.KSPLICE.*\.pre/) {
			unlink($_);
		}
	}
}
revert_orig();

if(!$skip_prebuild &&
   runval_raw(@make_ksplice, "KSPLICE_MODE=snap") != 0) {
	die "Aborting: Prebuild failed";
}
exit(0) if($prebuild);
runval("patch $patch_opt -bz .KSPLICE_pre < $patchfile");
if(runval_raw(@make_ksplice, "KSPLICE_MODE=diff") != 0) {
	revert_orig();
	die "Aborting: Applying the patch appears to break the kernel build";
}

sub copy_debug {
	my ($file) = @_;
	my ($dir, $base) = (dirname($file), basename($file));
	mkpath("$tmpdir/objects/$dir");
	copy($file, "$tmpdir/objects/$file");
	my $cmdfile = "$dir/.$base.cmd";
	copy($cmdfile, "$tmpdir/objects/$cmdfile") if(-e $cmdfile);
}

mkdir("$tmpdir/objects");
for (split(/\0/, runstr(qw(find -name *.KSPLICE* ! ( -name *.KSPLICE -empty ) ! -name .*.KSPLICE.cmd -print0)))) {
	copy_debug($_);
	copy_debug($1) if (m/^(.*)\.KSPLICE_pre$/);
}

mkdir("$tmpdir/collect");

my @modules = ();
foreach(glob(".tmp_versions/*.mod.KSPLICE")) {
	open MOD, '<', $_;
	chomp(my $module = <MOD>);
	close MOD;
	foreach my $collect ("$module.o.KSPLICE", "$module.o.KSPLICE_primary",
			     "$module.o.KSPLICE_helper") {
		copy($collect, "$tmpdir/collect/" . basename($collect));
	}
	push @modules, basename($module);
}

if(!@modules) {
	revert_orig();
	die "Aborting: No changes detected";
}

revert_orig();

for my $module (@modules) {
	chdir("$tmpdir/collect");

################################################################################
# PHASE 3: Combine the target object files and prepare for kernel module build #
# - links the many target object files into two "collection" object files      #
# - saves the reloc info extracted earlier in ELF sect .ksplice.ksplice_relocs #
# - uses objmanip's sizelist mode to save the names and sizes of target funcs  #
# - uses ld-script to aggregate all ELF text sections into .text               #
# - saves the list of target entry syms in ELF sect .ksplice.ksplice_patches   #
################################################################################

	chdir($tmpdir);
	runval("cp", "-a", "--", "$datadir/kmodsrc", "kmodsrc-$module");
	rename("collect/$module.o.KSPLICE_primary", "kmodsrc-$module/collection.o.primary");
	rename("collect/$module.o.KSPLICE_helper", "kmodsrc-$module/collection.o.helper");
	chdir("kmodsrc-$module");

	runsuc("objmanip", "collection.o.primary", "sourcediff", $patchfile);

	rename("collection.o.primary", "collection.o.primary.preld");
	runval("ld", "--script=ld-script", "-r", "-o", "collection.o.primary", "collection.o.primary.preld");
	rename("collection.o.helper", "collection.o.helper.preld");
	runval("ld", "--script=ld-script", "-r", "-o", "collection.o.helper", "collection.o.helper.preld");

###############################################################################
# PHASE 4: Build the kernel modules and create the update tarball             #
# - builds primary and helper kernel modules                                  #
# - uses objmanip's rmsyms mode to remove relocations to non-exported symbols #
# - creates a tarball of the primary module and the helper module             #
###############################################################################

	my $kid_m = "${kid}_$module";
	$kid_m =~ s/-/_/g;
	my $ksplice_m = "ksplice-$kid_m";
	runval("make", @jlevel, "modules", "KSPLICE_ID=$kid_m", "KSPLICE_TARGET=$module", "map_printk=$map_printk", "KERNELSRC=$linuxtree", @standalone_flag);
}

chdir($tmpdir);
mkdir($ksplice);
move($patchfile, $ksplice);
for my $module (@modules) {
	my $kid_m = "${kid}_$module";
	$kid_m =~ s/-/_/g;
	my $ksplice_m = "ksplice-$kid_m";
	rename("kmodsrc-$module/$ksplice_m.ko", "$ksplice/$ksplice_m.ko");
	rename("kmodsrc-$module/$ksplice_m-helper.ko", "$ksplice/$ksplice_m-helper.ko");
}
if($ksplice_in_kernel eq 'm' && ! $standalone) {
	open FILE, '>', "$ksplice/need_modprobe_ksplice" and close FILE or die;
}
mkdir("$ksplice/debug");
rename("objects", "$ksplice/debug/objects");
rename("collect", "$ksplice/debug/collect");
for my $module (@modules) {
	rename("kmodsrc-$module", "$ksplice/debug/kmodsrc-$module");
}
runval("tar", "czf", "$ksplice.tar.gz", "--", $ksplice);
copy("$ksplice.tar.gz", "$origdir/$ksplice.tar.gz");

print "Ksplice update tarball written to $ksplice.tar.gz\n";

if($apply) {
	print "Now running ksplice-apply to apply update...\n";
	exec("ksplice-apply", $ksplice) || die;
}

exit(0);

=head1 NAME

ksplice-create - Create a set of kernel modules for a rebootless kernel update

=head1 SYNOPSIS

B<ksplice-create> [B<--config=>I<ORIG_CONFIG>] B<--patch=>I<PATCH_FILE> I<KERNEL_SOURCE>

B<ksplice-create> [B<--config=>I<ORIG_CONFIG>] B<--diffext=>I<EXTENSION> I<KERNEL_SOURCE>

B<ksplice-create> [B<--config=>I<ORIG_CONFIG>] B<--prebuild> I<KERNEL_SOURCE>

=head1 DESCRIPTION

B<ksplice-create> creates a set of Ksplice kernel modules that, when loaded,
will apply a user-specified source code patch to the running binary kernel.

Before you use B<ksplice-create> on a patch, you should confirm that the
desired source code change does not make any semantic changes to kernel data
structures--that is, changes that would require existing instances of kernel
data structures to be transformed (e.g., a patch that adds a field to a global
data structure would require the existing data structures to change).  If you
use Ksplice on a patch that changes data structure semantics, Ksplice will not
detect the problem and you could experience kernel problems as a result.

The to-be-applied source code patch can be specified by providing a L<patch(1)>
file (B<--patch=>I<PATCH_FILE>) or by providing a file extension
(B<--diffext=>I<EXTENSION>).

If a file extension is specified, then the desired source code patch will be
determined by comparing all of the files in the I<KERNEL_SOURCE> directory tree
whose names end with the extra extension I<EXTENSION> against the corresponding
files without the extra extension.  Only the new files containing the extra
extension in their filenames should be modified.

Here is an example of using a file extension to specify a patch:

 $ cp KERNEL_SOURCE/kernel/sys.c KERNEL_SOURCE/kernel/sys.c.prctl_fixed
 [edit sys.c.prctl_fixed to include the desired changes]
 $ ksplice-create --diffext=.prctl_fixed KERNEL_SOURCE

KERNEL_SOURCE must be a directory containing the to-be-updated kernel's
original source code.  If your Linux distribution applies patches to the Linux
kernel during the kernel build process, then those patches must be applied to
the I<KERNEL_SOURCE> directory before invoking B<ksplice-create> on that
directory.  B<ksplice-create> will not modify the source code in the
I<KERNEL_SOURCE> directory tree, but it will perform a kernel build in that
directory tree.

I<ORIG_CONFIG> can be used to specify the directory containing the
to-be-updated kernel's original F<.config> file and original F<System.map> file
(the files should have exactly those names).  I<ORIG_CONFIG> defaults to
I<KERNEL_SOURCE>B</ksplice>.

The default L<gcc(1)> compiler and L<as(1)> assembler on the system should be as
close to the compiler and assembler originally used to build the running kernel
as possible.  If the current compiler and linker are too different from the
original compiler and linker, B<ksplice-apply> will abort when applying the
update.

B<ksplice-create> outputs a L<tar(1)> file, compressed with L<gzip(1)>,
containing the desired Ksplice update modules.  This tarball will be created in
the current directory, and it can be manipulated using the other Ksplice
utilities, such as B<ksplice-apply>.

The first time that B<ksplice-create> is invoked on a I<KERNEL_SOURCE>
directory, it must build that kernel from scratch, which is much slower than
the rest of the update-creation process.  B<--prebuild> can be used to perform
this initial kernel build without providing a source code patch.

In order to patch a function that has previously been patched by Ksplice, the
user needs to ensure that the I<KERNEL_SOURCE> directory provided to Ksplice
contains the source for the currently running kernel, including any patches
that have previously been applied by Ksplice.

=head1 OPTIONS

=over 8

=item B<-v>, B<--verbose>

Prints the commands being executed, the output of the commands being executed,
and various other pieces of information.

=item B<-j> I<JOBS>, B<--jobs=>I<JOBS>

Specifies the number of jobs to run simultaneously while performing kernel
builds.  B<ksplice-create> also honors the environment variable
CONCURRENCY_LEVEL.

=item B<--apply>

Immediately applies the generated update to the running kernel by invoking
B<ksplice-apply>.

=item B<--patch-opt=>I<OPTIONS>

Can be used to pass options to L<patch(1)>.  If this option is NOT specified, then
B<-p1> is passed to B<patch>.  If this option is specified, then only the
specified options will be passed to B<patch>.  This option can be repeated in
order to pass multiple options to B<patch>.  This option is ignored when the
to-be-applied source code patch is specified using B<--diffext>.

=item B<--id=>I<ID>

Specifies the unique value that will be used as the identifier of the
Ksplice update.  This identifier will, for example, appear in the name
of the update tarball.  By default, a random 8-character ID will be
generated.

=back

=head1 BUGS

Please report bugs to <PACKAGE_BUGREPORT>.

=head1 SEE ALSO

L<ksplice-apply(8)>, L<ksplice-view(8)>, L<ksplice-undo(8)>

=head1 COPYRIGHT

Copyright (C) 2008  Jeffrey Brian Arnold <jbarnold@mit.edu>.

This is free software and documentation.  You can redistribute and/or modify it
under the terms of the GNU General Public License, version 2.

=cut
