#!/usr/bin/perl

# Copyright (C) 2008  Jeffrey Brian Arnold <jbarnold@mit.edu>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License, version 2.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
# 02110-1301, USA.

use strict;
use warnings;
use lib 'KSPLICE_DATA_DIR';
use Ksplice;

my ($help, $wantversion, $debug) = (0, 0, 0);
GetOptions("help|?" => \$help,
	"version" => \$wantversion,
	"verbose|v:+" => \$Verbose::level,
	"debug=i" => \$debug) or pod2usage(1);

if($wantversion) {
	print $version_str;
	exit(0);
}
pod2usage(1) if($help || scalar(@ARGV) != 1);

my $file = abs_path($ARGV[0]);

my $tmpdir = tempdir('ksplice-tmp-XXXXXX', TMPDIR => 1, CLEANUP => 1);
chdir($tmpdir);
my $ksplice = unpack_update($file);
chdir($ksplice);

my $unload = runstr("lsmod") !~ m/- $/m;

runstr_err(qw(modprobe -q ksplice)) eq "" || die;
(my $kid = $ksplice) =~s|ksplice[-_]([^-_]+)|$1|;
if (-e "ksplice-$kid.ko") {
	system(qw(insmod), "ksplice-$kid.ko") == 0 || die;
}
foreach my $helper (glob('ksplice-*-helper.ko')) {

	(my $primary = $helper) =~ s/\-helper\.ko$/.ko/;
	die unless(-e $primary && -e $helper);

	my ($newkid, $target) = $primary =~ m/^ksplice-([^_]+)_(.*)\.ko/;
	if ($target ne 'vmlinux' && runstr("lsmod") !~ m/^${target}\s/m) {
		die "Module $target to be patched not loaded";
	}
	my $mid = "${kid}_$target";
	my $module = "ksplice_$mid";

	die "/sys not mounted\n" unless (-d "/sys/module");
	if(-d "/sys/module/$module/ksplice") {
		open STAGE, '<', "/sys/module/$module/ksplice/stage";
		if (<STAGE> eq "applied\n") {
			print STDERR "Ksplice update $mid already applied; continuing\n";
			next;
		}
		die "Unapplied Ksplice module $mid already loaded!";
	}

	if(runval_raw("insmod $primary debug=$debug") != 0) {
		die "Error loading primary module $primary";
	}
	if(runval_raw("insmod $helper") != 0) {
		(my $modname = $primary) =~ s/\.ko$//;
		$modname =~ s/-/_/g;
		my (undef, $debugfs_out) = tempfile('ksplice-debug-XXXXXX',
						    DIR => tmpdir());
		my $debug = get_debugfs($modname, $debugfs_out);
		if (!defined($debug)) {
			my $dmesg = runstr("dmesg | grep ksplice");
			while($dmesg =~ /ksplice_h: Preparing and checking/) {
				$dmesg = $';
			}
			$debug = $dmesg;
		}
		open(ABORT, '<', "/sys/module/$module/ksplice/abort_cause")
		    or die $!;
		chomp(my $abort_cause = <ABORT>);
		close(ABORT);
		runval_raw("rmmod $primary") if $unload;
		print STDERR "Error applying Ksplice update $kid:\n";
		print "$debug";
		print_error($abort_cause);
		print("Debugging output saved to $debugfs_out\n");
		die;
	}
	die if ($unload && runval_raw("rmmod $helper") != 0)

}

print "Done!\n";
exit(0);

sub print_error {
	my ($error) = @_;
	my %errors = (
		"no_match" => <<'END',
Ksplice has aborted the upgrade because Ksplice has been unable to match the
object code produced by your current compiler and assembler against the running
kernel's object code.  If you provided the exact kernel source to the running
kernel, then it appears that your current compiler and/or assembler are
behaving differently from the compiler and assembler used to build the running
kernel.  If possible, please use the exact compiler and assembler that were
used to build the running kernel.  If you are using exactly the same compiler
and assembler, feel free to report a bug to PACKAGE_BUGREPORT.
END
		"code_busy" => <<'END',
Ksplice has aborted the upgrade because it appears that the code that you are
trying to patch is continuously in use by the system.  More specifically,
Ksplice has been unable to find a moment when one or more of the to-be-patched
functions is not on a thread's kernel stack.
END
		"bad_system_map" => <<'END',
Ksplice has aborted the upgrade because it appears that the System.map file
provided to ksplice-create does not match the running kernel.
END
		"failed_to_find" => <<'END',
Ksplice has aborted the upgrade because it was unable to resolve some
of the symbols used in the update.
END
		"UNKNOWN" => <<'END',
The Ksplice kernel interface has returned an error string that
ksplice-apply does not understand.  This is probably the result of
using a version of ksplice-apply that is older than the version of the
Ksplice kernel module source.
END
		"none" => <<'END',
Ksplice has aborted the upgrade for unknown reasons.
END
	);
	$error = "UNKNOWN" if (!exists $errors{$error});
	print STDERR "\n$errors{$error}\n";
}

=head1 NAME

ksplice-apply - Apply an on-disk Ksplice update to the running kernel

=head1 SYNOPSIS

B<ksplice-apply> I<UPDATE_TARBALL>

=head1 DESCRIPTION

B<ksplice-apply> takes as input a Ksplice update tarball, as generated by
L<ksplice-create(8)>, and it applies the update to the running binary kernel.

Specifically, B<ksplice-apply> does the following:

=over

=item 1.

Inserts the "primary" module into the kernel.

=item 2.

Inserts the "helper" module into the kernel (doing so applies the
update).

=item 3.

Removes the "helper" module from the kernel (that module is not needed
after the update has been applied).

=back

The update tarball used with B<ksplice-apply> must have been generated for the
running kernel's version.

=head1 OPTIONS

=over 8

=item B<--debug=>I<DEBUG_LEVEL>

Applies the update with debugging output enabled.  Recommended only for
debugging.  I<DEBUG_LEVEL> should be an integer between 0 and 4.  B<--debug=4>
provides the most debugging information.

=over

=item Z<> B<0>

No debugging output.

=item Z<> B<1>

Provides basic (pre-run matching and kernel stack check) debugging output.

=item Z<> B<2>

Also provides full kernel stack check debugging output.

=item Z<> B<3>

Also provides full pre-run matching debugging output.

=item Z<> B<4>

Also provides full Ksplice relocation debugging output.

=back

=back

=head1 SEE ALSO

L<ksplice-create(8)>, L<ksplice-view(8)>, L<ksplice-undo(8)>

=head1 COPYRIGHT

Copyright (C) 2008  Jeffrey Brian Arnold <jbarnold@mit.edu>.

This is free software and documentation.  You can redistribute and/or modify it
under the terms of the GNU General Public License, version 2.

=cut
