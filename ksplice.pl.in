#!/usr/bin/perl

# Copyright (C) 2008  Anders Kaseorg <andersk@mit.edu>,
#                     Jeffrey Brian Arnold <jbarnold@mit.edu>,
#                     Tim Abbott <tabbott@mit.edu>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License, version 2.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
# 02110-1301, USA.

use strict;
use warnings;
use lib 'KSPLICE_DATA_DIR';
use ksplice;
use File::Copy;
use Digest::MD5;

sub empty_diff {
	my ($out) = @_;
	my ($obj) = $out =~ /^(.*)\.KSPLICE$/ or die;
	unlink "$obj.KSPLICE_primary" if (-e "$obj.KSPLICE_primary");
	unlink "$obj.KSPLICE_helper" if (-e "$obj.KSPLICE_helper");
	open OUT, '>', "$out.tmp";
	close OUT;
	rename "$out.tmp", $out;
}

sub do_snap {
	my ($out) = @_;
	my ($obj) = $out =~ /^(.*)\.KSPLICE$/ or die;
	die if (!-e $obj);
	unlink "$obj.KSPLICE_pre" if (-e "$obj.KSPLICE_pre");
	empty_diff($out);
}

my %syms;
my $word;

sub do_diff {
	my ($out) = @_;
	my ($obj) = $out =~ /^(.*)\.KSPLICE$/ or die;
	my $obj_old = "$obj.KSPLICE_pre";
	return do_snap($out) if (!-e $obj_old);
	die if (!-e $obj);
	if (system('cmp', '-s', '--', $obj_old, $obj) == 0) {
		unlink $obj_old;
		return empty_diff($out);
	}

	my ($bits, $sections, $entrysyms) = split("\n", runsuc("objdiff", $obj_old, $obj));
	die if ($bits ne '32' && $bits ne '64');
	return empty_diff($out) if ($sections eq '' && $entrysyms eq '');

	$word = ($bits == 64 ? "quad" : "long");

	copy($obj, "$obj.KSPLICE_primary");
	copy($obj_old, "$obj.KSPLICE_helper");

	open OBJ, '<', $obj or die;
	open OBJ_OLD, '<', $obj_old or die;
	my $tag = Digest::MD5->new->addfile(*OBJ)->addfile(*OBJ_OLD)->hexdigest;
	close OBJ;
	close OBJ_OLD;

	load_system_map();

	runsuc("objmanip", "$obj.KSPLICE_primary", "keep-primary", "____${tag}", "_post", split(/\s/, $sections));
	runsuc("objmanip", "$obj.KSPLICE_primary", "globalize", "____${tag}_post");

	runsuc("objmanip", "$obj.KSPLICE_helper", "keep-helper", "____${tag}", "_pre");
	runsuc("objmanip", "$obj.KSPLICE_helper", "globalize", "____${tag}_pre");

	runsuc("objmanip", "$obj.KSPLICE_primary", "sizelist");
	runsuc("objmanip", "$obj.KSPLICE_helper", "sizelist");

	my $patchlist = "";
	foreach my $sym (split(/\s/, $entrysyms)) {
		$patchlist .= "${sym}____${tag}_pre ${sym}____${tag}_post\n";
	}
	parse_and_save(\&parse_patchlist, $patchlist, "$obj.KSPLICE_primary", "ksplice_patches");

	open OUT, '>', "$out.tmp";
	print OUT "$bits\n";
	close OUT;
	rename "$out.tmp", $out;
}

sub do_combine {
	my ($out, @ins) = @_;
	my @objs;
	my $outbits = undef;
	foreach my $in (@ins) {
		next if (!-s $in);
		my ($obj) = $in =~ /^(.*)\.KSPLICE$/ or die;
		push @objs, $obj;

		open IN, '<', $in;

		chomp(my $bits = <IN>);
		die if (defined $outbits && $outbits ne $bits);
		$outbits = $bits;

		close IN;
	}

	return empty_diff($out) unless (defined $outbits);

	my ($obj) = $out =~ /^(.*)\.KSPLICE$/ or die;
	if (@objs == 1) {
		copy "$objs[0].KSPLICE_primary", "$obj.KSPLICE_primary";
		copy "$objs[0].KSPLICE_helper", "$obj.KSPLICE_helper";
	} else {
		system("ld", "-r", "-o",
		       map { "$_.KSPLICE_primary" } ($obj, @objs));
		system("ld", "-r", "-o",
		       map { "$_.KSPLICE_helper" } ($obj, @objs));
	}

	open OUT, '>', "$out.tmp";
	print OUT "$outbits\n";
	close OUT;
	rename "$out.tmp", $out;
}

sub do_rmsyms {
	my ($obj, @rmsyms) = @_;
	my $relocs = runsuc("objmanip", $obj, "rmsyms", @rmsyms);
}

sub do_system_map_lookup {
	my ($sym) = @_;
	load_system_map();
	print ((find_sym_system_map($sym))[0]);
}

my %handlers = (
	'snap' => \&do_snap,
	'diff' => \&do_diff,
	'combine' => \&do_combine,
	'rmsyms' => \&do_rmsyms,
	'system_map_lookup' => \&do_system_map_lookup,
);

my ($cmd, @args) = @ARGV;
if (exists $handlers{$cmd}) {
	my $handler = $handlers{$cmd};
	&$handler(@args);
} else {
	print "Usage: ksplice.pl ", join('|', keys %handlers), " ...\n";
};

exit 0;

sub load_system_map {
	open(SYMS, "<", "$ENV{KSPLICE_CONFIG_DIR}/System.map") or die;
	my $line;
	while(defined($line = <SYMS>)) {
		my ($addr, $type, $sym, $mod) = split(/\s+/, $line);
		next if($sym =~ /init_module/ ||
			$sym =~ /cleanup_module/ ||
			$sym =~ /this_module/);

		$syms{$sym}{$addr} = 1;
	}
	close(SYMS);
}

sub find_sym_system_map {
	my ($sym) = @_;
	$sym =~ s/[.]text[.]//g;
	$sym =~ s/[.]bss[.]//g;
	$sym =~ s/[.]data[.]//g;
	$sym =~ s/____.*//g;
	if(defined $syms{$sym}) {
		return keys(%{$syms{$sym}});
	}
	return ();
}

sub parse_and_save {
	my ($funcref, $entries, $objfile, $suffix, @other) = @_;
	my @entries = split(/\n/, $entries);

	my @tosave;
	foreach my $entry (@entries) {
		print $entry, "\n" if($verbose);
		&$funcref(\@tosave, $entry, @other);
	}
	save_using_asm(\@tosave, $objfile, $suffix);
}

sub save_using_asm {
	my ($tosaveref, $objfile, $suffix) = @_;

	my $asm_base = "$objfile.$suffix";

	open(ASM, ">", "$asm_base.s");
	print ASM ".section .${suffix}, \"a\"\n";

	foreach my $entryref (@$tosaveref) {
		my @entry = @{$entryref};

		if($entry[0] eq "str") {
			print ASM ".section .ksplice_str, \"a\"\n";
			print ASM "0: .string \"", $entry[1], "\"\n";
			print ASM ".section .${suffix}, \"a\"\n";
			print ASM ".$word 0b\n";
		}
		elsif($entry[0] eq "array" && scalar(@entry) == 1) {
			print ASM ".section .${suffix}, \"a\"\n";
			print ASM ".$word 0x0\n";
		}
		elsif($entry[0] eq "array") {
			print ASM ".section .ksplice_array, \"a\"\n";
			print ASM "0:\n";
			for(my $i = 1; $i < scalar(@entry); $i++) {
				print ASM ".$word 0x", $entry[$i], "\n";
			}
			print ASM ".section .${suffix}, \"a\"\n";
			print ASM ".$word 0b\n";
		}
		elsif($entry[0] eq "word") {
			print ASM ".section .${suffix}, \"a\"\n";
			print ASM ".$word 0x", $entry[1], "\n";
		}
		elsif($entry[0] eq "ptr") {
			print ASM ".section .${suffix}, \"a\"\n";
			print ASM ".$word ", $entry[1], "\n";
		}
		else { die; }
	}
	close(ASM);

	runval("gcc", "-mcmodel=kernel", "-c", "$asm_base.s", "-o", "$asm_base.o");
	runval("mv", $objfile, "$objfile.pre$suffix");
	runval("ld", "-r", "-o", "$objfile", "$objfile.pre$suffix", "$asm_base.o");
}

sub parse_patchlist {
	my ($tosaveref, $entry) = @_;
	my ($oldsym, $replsym) = split(/\s/, $entry);

	push @$tosaveref, (["str", $oldsym], ["str", $replsym],
		["word", 0], ["ptr", "${replsym}_global"],
		["word", 0]);
}
