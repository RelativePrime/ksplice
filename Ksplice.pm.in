package Ksplice;
use Cwd qw(abs_path getcwd);
use Getopt::Long qw(:config bundling);
use File::Basename;
use File::Copy;
use File::Path;
use File::Spec::Functions qw(tmpdir);
use File::Temp qw(tempfile tempdir);
use Fatal qw(:void copy rename move chdir mkdir unlink rmtree);
use IPC::Open3;
use Pod::Usage;
use Text::ParseWords;
use strict;
use warnings;
use Verbose qw(:2 copy rename move chdir mkdir mkpath unlink rmtree tempfile tempdir);
require Exporter;
our @ISA = qw(Exporter);
our @EXPORT = qw(
	Verbose GetOptions pod2usage shellwords
	$datadir $libexecdir $version_str
	runval runval_raw runstr runstr_err runsuc unpack_update
	get_stage set_stage set_debug_level get_abort_cause get_patch update_loaded
	get_debug_output
	abs_path getcwd basename dirname tmpdir
	copy rename move chdir mkdir mkpath unlink rmtree tempfile tempdir
);

our ($datadir, $libexecdir) = qw(KSPLICE_DATA_DIR KSPLICE_LIBEXEC_DIR);
our $version_str = "Ksplice version PACKAGE_VERSION\n";

sub runval {
	my (@cmd) = @_;
	if(runval_raw(@cmd) != 0) {
		die "Failed during: @cmd\n";
	}
}

sub runval_raw {
	my (@cmd) = @_;
	my ($out, $err);
	print "+ @cmd\n" if($Verbose::level >= 1);
	if($Verbose::level < 1) {
		open $out, ">&STDOUT" or die "Can't dup STDOUT: $!";
		open $err, ">&STDERR" or die "Can't dup STDERR: $!";
		open STDOUT, '>', "/dev/null" or die "Can't hide STDOUT: $!";
		open STDERR, '>', "/dev/null" or die "Can't hide STDERR: $!";
	}
	my $val = system(@cmd);
	if($Verbose::level < 1) {
		open STDOUT, ">&", $out or die "Can't restore STDOUT: $!";
		open STDERR, ">&", $err or die "Can't restore STDERR: $!";
	}
	return $val;
}

sub runstr {
	my @cmd = @_;
	print "+ @cmd\n" if($Verbose::level >= 1);
	local $/;
	open PIPE, '-|', @cmd or die "Can't run @cmd: $!";
	my $output = <PIPE>;
	close PIPE or $! == 0 or die "Can't run @cmd: $!";
	return $output;
}

sub runstr_err {
	my @cmd = @_;
	print "+ @cmd\n" if($Verbose::level >= 1);
	my $pid = open3(\*WRITE, \*READ, \*ERROR, @cmd);
	waitpid($pid, 0);
	local $/;
	return <ERROR>;
}

sub runsuc {
	my ($cmd, @args) = @_;
	my $output = runstr("$libexecdir/ksplice-$cmd", @args);
	if($? != 0) {
		print "Output: $output\n";
		die "Failed during: $libexecdir/ksplice-$cmd @args";
	}
	return $output;
}

sub unpack_update {
	my ($file) = @_;
	runval("tar", "zxf", $file);
	my ($ksplice) = glob('*/');
	chop($ksplice); # remove the trailing slash
	return $ksplice;
}

sub get_sysfs {
	my ($kid) = @_;
	if(! -d "/sys/module") {
		die "/sys not mounted?\n";
	}
	my $update = "ksplice_$kid";
	if (-d "/sys/module/ksplice/$update") {
		return "/sys/module/ksplice/$update";
	}
	if (-d "/sys/module/$update/$update") {
		return "/sys/module/$update/$update";
	}
	return undef;
}

sub update_loaded {
	my ($kid) = @_;
	return defined(get_sysfs($kid));
}

sub read_file {
	my ($file) = @_;
	local (*INPUT, $/);
	open(INPUT, "<", $file) or die $!;
	return <INPUT>;
}

sub write_file {
	my ($file, $string) = @_;
	local *INPUT;
	open(INPUT, ">", $file) or die $!;
	print INPUT $string;
}

sub read_sysfs {
	my ($kid, $attr) = @_;
	my $sysfs = get_sysfs($kid);
	return undef if (!defined($sysfs));
	return read_file("$sysfs/$attr");
}

sub write_sysfs {
	my ($kid, $attr, $string) = @_;
	my $sysfs = get_sysfs($kid);
	return undef if (!defined($sysfs));
	write_file("$sysfs/$attr", $string);
}

sub get_debug_output {
	my ($kid) = @_;
	my $update = "ksplice_$kid";
	my $debug;
	my (undef, $debugfs_out) = tempfile('ksplice-debug-XXXXXX', DIR => tmpdir());
	my $debugfsdir = tempdir('ksplice-debugfs-XXXXXX',
				 TMPDIR => 1, CLEANUP => 1);
	runval_raw(qw(mount -t debugfs debugfs), $debugfsdir);
	if (-e "$debugfsdir/$update") {
		copy("$debugfsdir/$update", "$debugfs_out");
		$debug = read_file("$debugfsdir/$update");
	} else {
		my $dmesg = runstr("dmesg | grep ksplice");
		while($dmesg =~ /ksplice: Preparing to reverse/) {
			$dmesg = $';
		}
		$debug = $dmesg;
		write_file($debugfs_out, $dmesg);
	}
	runval_raw(qw(umount), $debugfsdir);
	rmdir($debugfsdir);
	return ($debugfs_out, $debug);
}

sub get_stage {
	my ($kid) = @_;
	chomp(my $result = read_sysfs($kid, "stage"));
	return $result;
}

sub get_abort_cause {
	my ($kid) = @_;
	chomp(my $result = read_sysfs($kid, "abort_cause"));
	return $result;
}

sub get_patch {
	my ($kid) = @_;
	chomp(my $result = read_sysfs($kid, "source_diff"));
	return $result;
}

sub set_stage {
	my ($kid, $string) = @_;
	write_sysfs($kid, "stage", "$string\n");
}

sub set_debug_level {
	my ($kid, $string) = @_;
	write_sysfs($kid, "debug", "$string\n");
}

END {
	$Verbose::level = 0;
	chdir("/");
}

1;
