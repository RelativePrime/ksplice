package Ksplice;
use Cwd qw(abs_path getcwd);
use Getopt::Long qw(:config bundling);
use File::Basename;
use File::Copy;
use File::Path;
use File::Spec::Functions qw(tmpdir);
use File::Temp qw(tempfile tempdir);
use Fatal qw(:void copy rename move chdir mkdir unlink rmtree);
use IPC::Open2;
use IPC::Open3;
use Pod::Usage;
use Text::ParseWords;
use strict;
use warnings;
use Verbose qw(:2 copy rename move utime chdir mkdir mkpath unlink rmtree tempfile tempdir);
require Exporter;
our @ISA = qw(Exporter);
our @EXPORT = qw(
	Verbose GetOptions pod2usage shellwords
	$datadir $libexecdir $version_str
	child_error runval runval_raw runstr runstr_err runval_in runval_infile unpack_update
	get_stage set_stage set_debug_level get_abort_cause get_patch update_loaded
	get_debug_output get_conflicts
	abs_path getcwd basename dirname tmpdir
	copy rename move utime chdir mkdir mkpath unlink rmtree tempfile tempdir
);

our ($datadir, $libexecdir) = qw(KSPLICE_DATA_DIR KSPLICE_LIBEXEC_DIR);
our $version_str = "Ksplice version PACKAGE_VERSION\n";

sub child_error {
	if($? == -1) {
		print STDERR "Failed to exec child\n";
	} elsif(($? & 127) != 0) {
		print STDERR "Child exited with signal ", ($? & 127), ($? & 128) ? " (core dumped)\n" : "\n";
	} elsif($? >> 8 != 0) {
		print STDERR "Child exited with status ", $? >> 8, "\n";
	} else {
		return 0;
	}
	return 1;
}

sub runval {
	my (@cmd) = @_;
	if(runval_raw(@cmd) != 0) {
		child_error();
		die "Failed during: @cmd\n";
	}
}

sub runval_raw {
	my (@cmd) = @_;
	my ($out, $err);
	print "+ @cmd\n" if($Verbose::level >= 1);
	if($Verbose::level < 1) {
		open $out, ">&STDOUT" or die "Can't dup STDOUT: $!";
		open $err, ">&STDERR" or die "Can't dup STDERR: $!";
		open STDOUT, '>', "/dev/null" or die "Can't hide STDOUT: $!";
		open STDERR, '>', "/dev/null" or die "Can't hide STDERR: $!";
	}
	my $val = system(@cmd);
	if($Verbose::level < 1) {
		open STDOUT, ">&", $out or die "Can't restore STDOUT: $!";
		open STDERR, ">&", $err or die "Can't restore STDERR: $!";
	}
	return $val;
}

sub runstr {
	my @cmd = @_;
	print "+ @cmd\n" if($Verbose::level >= 1);
	local $/;
	open PIPE, '-|', @cmd or die "Can't run @cmd: $!";
	my $output = <PIPE>;
	close PIPE or $! == 0 or die "Can't run @cmd: $!";
	return $output;
}

sub runstr_err {
	my @cmd = @_;
	print "+ @cmd\n" if($Verbose::level >= 1);
	local (*ERROR);
	my $pid = open3(fileno STDIN, '>&STDOUT', \*ERROR, @cmd);
	local $/;
	my $error = <ERROR>;
	waitpid($pid, 0);
	print STDERR $error;
	return $error;
}

sub runval_in {
	my ($in, @cmd) = @_;
	print "+ @cmd <<'EOF'\n${in}EOF\n" if($Verbose::level >= 1);
	local (*WRITE);
	open(WRITE, '|-', @cmd) or die "Can't run @cmd: $!";
	print WRITE $in;
	close(WRITE) or $! == 0 or die "Can't run @cmd: $!";
	if(child_error()) {
		die "Failed during: @cmd";
	}
}

sub runval_infile {
	my ($infile, @cmd) = @_;
	print "+ @cmd < $infile\n" if($Verbose::level >= 1);
	local (*INFILE);
	open(INFILE, '<', $infile) or die "Can't open $infile: $!";
	my $pid = open2('>&STDOUT', '<&INFILE', @cmd) or die "Can't run @cmd: $!";
	waitpid($pid, 0);
	if(child_error()) {
		die "Failed during: @cmd";
	}
}

sub unpack_update {
	my ($file) = @_;
	runval("tar", "zxf", $file);
	my ($ksplice) = glob('*/');
	chop($ksplice); # remove the trailing slash
	return $ksplice;
}

sub get_sysfs {
	my ($kid) = @_;
	if(! -d "/sys/module") {
		die "/sys not mounted?\n";
	}
	my $update = "ksplice_$kid";
	if (-d "/sys/kernel/ksplice/$kid") {
		return "/sys/kernel/ksplice/$kid";
	}
	if (-d "/sys/module/$update/ksplice") {
		return "/sys/module/$update/ksplice";
	}
	return undef;
}

sub update_loaded {
	my ($kid) = @_;
	return defined(get_sysfs($kid));
}

sub read_file {
	my ($file) = @_;
	local (*INPUT, $/);
	open(INPUT, "<", $file) or die $!;
	return <INPUT>;
}

sub write_file {
	my ($file, $string) = @_;
	local *INPUT;
	open(INPUT, ">", $file) or die $!;
	print INPUT $string;
}

sub read_sysfs {
	my ($kid, $attr) = @_;
	my $sysfs = get_sysfs($kid);
	return undef if (!defined($sysfs));
	return read_file("$sysfs/$attr");
}

sub write_sysfs {
	my ($kid, $attr, $string) = @_;
	my $sysfs = get_sysfs($kid);
	return undef if (!defined($sysfs));
	write_file("$sysfs/$attr", $string);
}

sub get_debug_output {
	my ($kid) = @_;
	my $update = "ksplice_$kid";
	my $debug;
	my (undef, $debugfs_out) = tempfile('ksplice-debug-XXXXXX', DIR => tmpdir());
	my $debugfsdir = tempdir('ksplice-debugfs-XXXXXX',
				 TMPDIR => 1, CLEANUP => 1);
	if (runval_raw(qw(mount -t debugfs debugfs), $debugfsdir) == 0) {
		copy("$debugfsdir/$update", "$debugfs_out");
		$debug = read_file("$debugfsdir/$update");
		runval(qw(umount), $debugfsdir);
	} elsif ($? >> 8 == 32) {
		my $dmesg = runstr("dmesg | grep ksplice");
		while($dmesg =~ /ksplice: Preparing to reverse/) {
			$dmesg = $';
		}
		$debug = '';
		write_file($debugfs_out, $dmesg);
	} else {
		child_error();
		die;
	}
	return ($debugfs_out, $debug);
}

sub get_stage {
	my ($kid) = @_;
	chomp(my $result = read_sysfs($kid, "stage"));
	return $result;
}

sub get_abort_cause {
	my ($kid) = @_;
	chomp(my $result = read_sysfs($kid, "abort_cause"));
	return $result;
}

sub get_conflicts {
	my ($kid) = @_;
	chomp(my $conflicts = read_sysfs($kid, "conflicts"));
	my @conflicts = split('\n', $conflicts);
	my $out = '';
	foreach my $conflict (@conflicts) {
		my ($name, $pid, @symbols) = split(' ', $conflict);
		next if (!@symbols);
		$out .= "Process $name(pid $pid) is using the following symbols changed by update $kid:\n";
		foreach my $symbol (@symbols) {
			$out .= "  $symbol\n";
		}
	}
	return $out;
}

sub get_patch {
	my ($kid) = @_;
	my $result = read_file("/var/run/ksplice/updates/$kid/patch");
	return $result;
}

sub set_stage {
	my ($kid, $string) = @_;
	write_sysfs($kid, "stage", "$string\n");
}

sub set_debug_level {
	my ($kid, $string) = @_;
	write_sysfs($kid, "debug", "$string\n");
}

END {
	$Verbose::level = 0;
	chdir("/");
}

1;
